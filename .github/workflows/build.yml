name: Test, build, deploy

on:
  pull_request:
    types: [opened, synchronize, reopened]
  push:
    branches:
      - '**'
    tags:
      - 'v-*'
env:
  CI: true
  DEV_REF: heads/develop
  STAGING_REF: heads/master
  PRODUCTION_REF: tags/v-*
  REVIEW_ENVIRONMENT: review
  DEVELOPMENT_ENVIRONMENT: development
  STAGING_ENVIRONMENT: staging
  PRODUCITON_ENVIRONMENT: production
  env_development: ${{secrets.env_development}}
  env_review: ${{secrets.env_review}}
  env_staging: ${{secrets.env_staging}}
  env_production: ${{secrets.env_production}}
  GCLOUD_AUTH: ${{ secrets.GCP_SA_KEY }}
  GAE_PROJECT: ${{ secrets.GAE_PROJECT }}
  GAE_SERVICE: ${{ secrets.GAE_SERVICE }}

jobs:
  dependencies:
    name: Install and cache dependencies
    runs-on: ubuntu-latest
    steps:
    - name: 'Checkout'
      uses: 'actions/checkout@v1'
    - name: Use Node.js 13
      uses: actions/setup-node@v1
      with:
        node-version: 13
    - name: Get yarn cache
      id: yarn-cache
      run: echo "::set-output name=dir::$(yarn cache dir)"
    - uses: actions/cache@v1
      id: cache-deps
      with:
        path: ${{ steps.yarn-cache.outputs.dir }}
        key: ${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}
        restore-keys: |
          ${{ runner.os }}-yarn-
    - name: Install dependencies
      run: yarn install --frozen-lockfile
      # if: steps.cache-deps.outputs.cache-hit != 'true'

  test:
    name: Run test suite
    runs-on: ubuntu-latest
    needs: dependencies
    steps:
    - name: 'Checkout'
      uses: 'actions/checkout@v1'
    - name: Use Node.js 13
      uses: actions/setup-node@v1
      with:
        node-version: 13
    - name: Get yarn cache
      id: yarn-cache
      run: echo "::set-output name=dir::$(yarn cache dir)"
    - uses: actions/cache@v1
      id: cache-deps
      with:
        path: ${{ steps.yarn-cache.outputs.dir }}
        key: ${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}
        restore-keys: |
          ${{ runner.os }}-yarn-
    - name: Install dependencies
      # if: steps.cache-deps.outputs.cache-hit != 'true'
      run: yarn install --frozen-lockfile
    - name: Run tests
      run: yarn test
    - name: Coverage Report
      uses: actions/upload-artifact@v1
      with:
        name: code-coverage-report
        path: lcov


  lint:
    name: Lint code
    runs-on: ubuntu-latest
    needs: dependencies
    steps:
    - name: 'Checkout'
      uses: 'actions/checkout@v1'
    - name: Use Node.js 13
      uses: actions/setup-node@v1
      with:
        node-version: 13
    - name: Get yarn cache
      id: yarn-cache
      run: echo "::set-output name=dir::$(yarn cache dir)"
    - uses: actions/cache@v1
      id: cache-deps
      with:
        path: ${{ steps.yarn-cache.outputs.dir }}
        key: ${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}
        restore-keys: |
          ${{ runner.os }}-yarn-
    - name: Install dependencies
      run: yarn install --frozen-lockfile
      # if: steps.cache-deps.outputs.cache-hit != 'true'

  build:
    name: Build project
    runs-on: ubuntu-latest
    needs: [lint, test]
    steps:
    - name: 'Checkout'
      uses: 'actions/checkout@v1'
    - name: Use Node.js 13
      uses: actions/setup-node@v1
      with:
        node-version: 13
    - name: Get yarn cache
      id: yarn-cache
      run: echo "::set-output name=dir::$(yarn cache dir)"
    - uses: actions/cache@v1
      id: cache-deps
      with:
        path: ${{ steps.yarn-cache.outputs.dir }}
        key: ${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}
        restore-keys: |
          ${{ runner.os }}-yarn-
    - name: Install dependencies
      run: yarn install --frozen-lockfile
      # if: steps.cache-deps.outputs.cache-hit != 'true'
    - uses: actions/cache@v1
      id: cache-build
      with:
        path: dist
        key: ${{ runner.os }}-build-${{ github.sha }}
    - name: Build project
      run: yarn run build
    - name: Archive build artifacts
      uses: actions/upload-artifact@v1
      with:
        name: dist
        path: dist

  deploy:
    name: Create Github Deployment
    runs-on: [ubuntu-latest, self-hosted]
    needs: build
    steps:
    - name: 'Checkout'
      uses: 'actions/checkout@v1'
    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v1
      with:
        node-version: 13
    - name: Get yarn cache
      id: yarn-cache
      run: echo "::set-output name=dir::$(yarn cache dir)"
    - uses: actions/cache@v1
      id: cache-deps
      with:
        path: ${{ steps.yarn-cache.outputs.dir }}
        key: ${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}
        restore-keys: |
          ${{ runner.os }}-yarn-
    - name: Install dependencies
      run: yarn install
      # if: steps.cache-deps.outputs.cache-hit != 'true'
    - uses: actions/cache@v1
      id: cache-build
      with:
        path: dist
        key: ${{ runner.os }}-build-${{ github.sha }}
    - name: Build project
      run: yarn run build
      if: steps.cache-build.outputs.cache-hit != 'true'
    - uses: actions/github-script@0.4.0
      name: Configure environment for deployment
      id: configure-deploy
      with:
        github-token: ${{github.token}}
        script: |
          const environments = {
            review: {
              ref: false
              name: process.env.REVIEW_ENVIROMENT,
              transient: true,
              production: false,
              gaeVersion: `pr-${context.payload.number}`,
              extraFlags: ''
              auto_inactive: false,
            },
            dev: {
              ref: process.env.DEV_REF,
              name: process.env.DEVELOPMENT_ENVIRONMENT,
              transient: false,
              production: false,
              gaeVersion:`${process.env.DEVELOPMENT_ENVIRONMENT}-${shortSha}`,
              extraFlags: ''
              auto_inactive: true,
            },
            staging: {
              ref: process.env.STAGING_REF,
              name: process.env.STAGING_ENVIRONMENT,
              transient: false,
              production: false,
              gaeVersion:`${process.env.STAGING_ENVIRONMENT}-${shortSha}`,
              extraFlags: ''
              auto_inactive: true,
            },
            production: {
              ref: process.env.PRODUCTION_REF,
              name: process.env.PRODUCTION_ENVIRONMENT,
              transient: false,
              production: true,
              gaeVersion: `${process.env.PRODUCTION_ENVIRONMENT}-${shortSha}`,
              extraFlags: '--promote'
              auto_inactive: true,
            },
          }
          const getFlags = env =>  `--no-stop-previous-version --version=${env.gaeVersion} --project=${gaeProject} -q ${env.extraFlags || ''}`;
          let environment = environments.review;
          let sourceRef = context.ref;
          let isPush = false
          let description = `Environment for ${sourceRef}`
          
          if (context.eventName === 'pull_request') {
            sourceRef = context.payload.pull_request.head.ref
          }
          if (context.eventName === 'push') {
            isPush = true
          }
          const gaeProject = process.env.GAE_PROJECT;
          const gaeService = process.env.GAE_SERVICE;
          const shortSha = context.sha.substr(0,8)

          // determine what environment we're acting on.
          if (isPush && sourceRef.indexOf(process.env.DEV_REF) > 1) {
            environment = environments.dev;
          } else if (isPush && sourceRef.indexOf(process.env.STAGING_REF) > 1) {
            environment = environments.staging;
          } else if (isPush && sourceRef.indexOf(process.env.PRODUCTION_REF) > 1) {
            environment = environments.production;
          }

          const flags = getFlags(environment)
          const production_environment = environment.production;
          const transient_environment = environment.transient;
          const url = `https://${environment.gaeVersion}-dot-${gaeService}-dot-${gaeProject}.appspot.com`

          console.info(`Setting env vars for env ${environment.name}`)
          const current_environment = environment.name;
          const rawEnvVars = process.env[`env_${current_environment}`];
          const env_vars =  JSON.parse(rawEnvVars);
          let secretyaml = "env_variables:\n"
          for (let [k,v] of Object.entries(env_vars)) {
            secretyaml += `  ${k}: '${v}'\n`
          }
          secretyaml += `  BUILD_SHA: '${context.sha}'\n`
          secretyaml += `  BUILD_REF: '${sourceRef}'\n`
          let buff = new Buffer(secretyaml);
          let base64data = buff.toString('base64');
          console.info(`::set-env name=ENV_SECRETS::${base64data}`);
          console.info(`::set-env name=TARGET_ENV::${JSON.stringify(environment)}`);
          console.info(`::set-env name=ENV_URL::${url}`);
          console.info(`::set-env name=DEPLOY_FLAGS::${flags}`);
    - uses: actions/github-script@0.4.0
      name: Create Deployment in github
      if: success()
      with:
        github-token: ${{github.token}}
        script: |
          let sourceRef = context.ref;
          if (context.eventName === 'pull_request') {
            sourceRef = context.payload.pull_request.head.ref
          }
          const description = `Environment for ${sourceRef}`
          const environment = JSON.parse(process.env.TARGET_ENV);
          const options = {
            owner: context.payload.repository.owner.login,
            repo: context.payload.repository.name,
            ref: sourceRef,
            environment: environment.name,
            environment_url: process.env.ENV_URL,
            production_environment: environment.production,
            transient_environment: environment.transient,
            description,
            required_contexts: [],
            mediaType: { previews: ['ant-man', 'flash'] },
            payload: { flags: process.env.DEPLOY_FLAGS },
          };
          let deploymentResponse = await github.repos.createDeployment(options);
          let deployment = deploymentResponse.data;
          if (deployment.message && deployment.message.indexOf('Auto-merged') !== -1)  {
            deploymentResponse = await github.repos.createDeployment(options);
            deployment = deploymentResponse.data;
          }
          console.info(`::set-env name=DEPLOYMENT_ID::${deployment.id}`);
    - uses: actions/github-script@0.2.0
      if: success()
      name: Set deployment to "In progress" in Github
      with:
        github-token: ${{github.token}}
        script: |
          const environment = JSON.parse(process.env.TARGET_ENV);
          await github.repos.createDeploymentStatus({
            owner: context.payload.repository.owner.login,
            repo: context.payload.repository.name,
            deployment_id: process.env.DEPLOYMENT_ID,
            state: "in_progress",
            auto_inactive: environment.auto_inactive,
            mediaType: { previews: ['ant-man', 'flash'] }
          })
    - name: Dump secrets to secret.yaml
      if: success()
      run: echo $ENV_SECRETS | base64 --decode > secret.yaml && rm -rf Dockerfile
    - name: 'Configure GCloud'
      uses: GoogleCloudPlatform/github-actions/setup-gcloud@master
      with:
        version: '275.0.0'
        service_account_key: ${{ secrets.GCP_SA_KEY }}
    - name: Deploy via gcloud app deploy
      if: success()
      run: "gcloud components install beta --quiet && gcloud beta app deploy $DEPLOY_FLAGS"
    - name: Create deploy status (failure)
      uses: actions/github-script@0.2.0
      if: failure()
      with:
        github-token: ${{github.token}}
        script: |
          const environment = JSON.parse(process.env.TARGET_ENV);
          await github.repos.createDeploymentStatus({
            owner: context.payload.repository.owner.login,
            repo: context.payload.repository.name,
            deployment_id: process.env.DEPLOYMENT_ID,
            state: "failure",
            auto_inactive: environment.auto_inactive,
            mediaType: { previews: ['ant-man', 'flash'] }
          })
    - name: Create deploy status (success)
      uses: actions/github-script@0.2.0
      if: success()
      with:
        github-token: ${{github.token}}
        script: |
          const environment = JSON.parse(process.env.TARGET_ENV);
          await github.repos.createDeploymentStatus({
            owner: context.payload.repository.owner.login,
            repo: context.payload.repository.name,
            deployment_id: process.env.DEPLOYMENT_ID,
            environment_url: process.env.ENV_URL,
            state: "success",
            auto_inactive: environment.auto_inactive,
            mediaType: { previews: ['ant-man', 'flash'] }
          })
          if (process.env.TARGET_ENV === process.env.REVIEW_ENVIRONMENT) {
            const commentPrefix = 'The code in this PR can be reached at'
            const body = `${commentPrefix} ${process.env.ENV_URL}`
            // get comments
            const commentResponse = await github.issues.listComments({
              owner: context.payload.repository.owner.login,
              repo: context.payload.repository.name,
              issue_number: context.payload.number,
              per_page: 20,
            })
            const comments = commentResponse.data
            const hasCommented = comments.find(c => c.body.indexOf(commentPrefix) !== -1)
            console.info('have we commented with deploy url?', hasCommented)
            if (!hasCommented) {
              // create comment with link to deployment.octokit.({
              await github.issues.createComment({
                owner: context.payload.repository.owner.login,
                repo: context.payload.repository.name,
                issue_number: context.payload.number,
                body,
              })
            } else {
              await github.issues.updateComment({
                owner: context.payload.repository.owner.login,
                repo: context.payload.repository.name,
                issue_number: context.payload.number,
                comment_id: hasCommented.id,
                body
              })
            }
          }
    - name: Create deploy status (cancelled)
      uses: actions/github-script@0.2.0
      if: cancelled()
      with:
        github-token: ${{github.token}}
        script: |
          const environment = JSON.parse(process.env.TARGET_ENV);
          await github.repos.createDeploymentStatus({
            owner: context.payload.repository.owner.login,
            repo: context.payload.repository.name,
            deployment_id: process.env.DEPLOYMENT_ID,
            state: "cancelled",
            auto_inactive: environment.auto_inactive,
          })

  publish:
    name: Run test suite
    runs-on: ubuntu-latest
    needs: deploy
    if: github.event_name == 'push' && startsWith(github.event.ref, 'refs/tags/v')
    steps:
    - name: 'Checkout'
      uses: 'actions/checkout@v1'
    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v1
      with:
        registry-url: 'https://npm.pkg.github.com'
        node-version: 13
        scope: '@svaj'
    - name: Get yarn cache
      id: yarn-cache
      run: echo "::set-output name=dir::$(yarn cache dir)"
    - uses: actions/cache@v1
      id: cache-deps
      with:
        path: ${{ steps.yarn-cache.outputs.dir }}
        key: ${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}
        restore-keys: |
          ${{ runner.os }}-yarn-
    - name: Install dependencies
      run: yarn install --frozen-lockfile
      # if: steps.cache-deps.outputs.cache-hit != 'true'
    - run: yarn release
      env:
        NODE_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
